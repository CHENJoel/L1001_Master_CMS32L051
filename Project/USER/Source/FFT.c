#include "fft.h"
#include "Function_Init.H"

// // // // // // // // // // // // // // struct compx dd[65]; //FFT数据
// // // // // // // // // // // // // // struct compx temp_dd;
// // // // // // // // // // // // // // uchar refreshflag[40];
// // // // // // // // // // // // // // uchar  LEDBuf[35];	  //15列；从左到右；亮的位为真（1）；
// // // // // // // // // // // // // // float iw[64] =
// // // // // // // // // // // // // // {
// // // // // // // // // // // // // // 	1.000, 0, 0.9952, -0.0980, 0.9808, -0.1951, 0.9569, -0.2903, 0.9239, -0.3827, 0.8819, -0.4714, 0.8315, -0.5556,
// // // // // // // // // // // // // // 	0.7730, -0.6344, 0.7071, -0.7071, 0.6344, -0.7730, 0.5556, -0.8315, 0.4714, -0.8819, 0.3827, -0.9239, 0.2903, -0.9569,
// // // // // // // // // // // // // // 	0.1951, -0.9808, 0.0980, -0.9952, 0.0, -1.0000, -0.0980, -0.9952, -0.1951, -0.9808, -0.2903, 0.9569, -0.3827, -0.9239,
// // // // // // // // // // // // // // 	-0.4714, -0.8819, -0.5556, -0.8315, -0.6344, -0.7730, -0.7071, -0.7071, -0.7730, -0.6344, -0.8315, -0.5556, -0.8819,
// // // // // // // // // // // // // // 	-0.4714,
// // // // // // // // // // // // // // 	-0.9239, -0.3827, -0.9569, -0.2903, -0.9808, -0.1951, -0.9952, -0.0980
// // // // // // // // // // // // // // };

// // // // // // // // // // // // // // //复数乘法
// // // // // // // // // // // // // // void ee(struct compx b1, uint8_t b2)
// // // // // // // // // // // // // // {
// // // // // // // // // // // // // // 	temp_dd.real = b1.real * iw[2 * b2] - b1.imag * iw[2 * b2 + 1];
// // // // // // // // // // // // // // 	temp_dd.imag = b1.real * iw[2 * b2 + 1] + b1.imag * iw[2 * b2];
// // // // // // // // // // // // // // }
// // // // // // // // // // // // // // //乘方函数
// // // // // // // // // // // // // // uint mypow(uint8_t nbottom, uint8_t ntop)
// // // // // // // // // // // // // // {
// // // // // // // // // // // // // // 	uint result = 1;
// // // // // // // // // // // // // // 	uint8_t t;
// // // // // // // // // // // // // // 	for (t = 0; t < ntop; t++)
// // // // // // // // // // // // // // 		result *= nbottom;
// // // // // // // // // // // // // // 	return result;
// // // // // // // // // // // // // // }
// // // // // // // // // // // // // // //快速傅立叶变换
// // // // // // // // // // // // // // void fft(struct compx *xin, uint8_t N)
// // // // // // // // // // // // // // {
// // // // // // // // // // // // // // 	uint8_t fftnum, i, j, k, l, m, n, disbuff, dispos, dissec;
// // // // // // // // // // // // // // 	struct compx t;
// // // // // // // // // // // // // // 	fftnum = N; //傅立叶变换点数
// // // // // // // // // // // // // // 	for (m = 1; (fftnum = fftnum / 2) != 1; m++)
// // // // // // // // // // // // // // 		;						 //求得M的值
// // // // // // // // // // // // // // 	for (k = 0; k <= N - 1; k++) //码位倒置
// // // // // // // // // // // // // // 	{
// // // // // // // // // // // // // // 		n = k;
// // // // // // // // // // // // // // 		j = 0;
// // // // // // // // // // // // // // 		for (i = m; i > 0; i--) //倒置
// // // // // // // // // // // // // // 		{
// // // // // // // // // // // // // // 			j = j + ((n % 2) << (i - 1));
// // // // // // // // // // // // // // 			n = n / 2;
// // // // // // // // // // // // // // 		}
// // // // // // // // // // // // // // 		if (k < j)
// // // // // // // // // // // // // // 		{
// // // // // // // // // // // // // // 			t = xin[1 + j];
// // // // // // // // // // // // // // 			xin[1 + j] = xin[1 + k];
// // // // // // // // // // // // // // 			xin[1 + k] = t;
// // // // // // // // // // // // // // 		} //交换数据
// // // // // // // // // // // // // // 	}
// // // // // // // // // // // // // // 	for (l = 1; l <= m; l++) // FFT运算
// // // // // // // // // // // // // // 	{
// // // // // // // // // // // // // // 		disbuff = mypow(2, l); //求得碟间距离
// // // // // // // // // // // // // // 		dispos = disbuff / 2;  //求得碟形两点之间的距离
// // // // // // // // // // // // // // 		for (j = 1; j <= dispos; j++)
// // // // // // // // // // // // // // 			for (i = j; i < N; i = i + disbuff) //遍历M级所有的碟形
// // // // // // // // // // // // // // 			{
// // // // // // // // // // // // // // 				dissec = i + dispos;								//求得第二点的位置
// // // // // // // // // // // // // // 				ee(xin[dissec], (uint)(j - 1) * (uint)N / disbuff); //复数乘法
// // // // // // // // // // // // // // 				t = temp_dd;
// // // // // // // // // // // // // // 				xin[dissec].real = xin[i].real - t.real;
// // // // // // // // // // // // // // 				xin[dissec].imag = xin[i].imag - t.imag;
// // // // // // // // // // // // // // 				xin[i].real = xin[i].real + t.real;
// // // // // // // // // // // // // // 				xin[i].imag = xin[i].imag + t.imag;
// // // // // // // // // // // // // // 			}
// // // // // // // // // // // // // // 	}
// // // // // // // // // // // // // // }

// // // // // // // // // // // // // // //完成显示数据的转换工作,包括顶点下落速度控制以及顶点更新定格
// // // // // // // // // // // // // // //对fft数据进行处理,得到各个频率段的电压幅值
// // // // // // // // // // // // // // void processfft(void)
// // // // // // // // // // // // // // {
// // // // // // // // // // // // // // 	uint8_t pt = 0, tmp;
// // // // // // // // // // // // // // 	uint8_t i;
// // // // // // // // // // // // // // 	float temp;
// // // // // // // // // // // // // // 	uint8_t tempNum;
// // // // // // // // // // // // // // 	if (DMAVEC->CTRL[CTRL_DATA_ADC].DMACT == 0)
// // // // // // // // // // // // // // 	{
// // // // // // // // // // // // // // 		for (pt = 0; pt < 65; pt++)
// // // // // // // // // // // // // // 		{
// // // // // // // // // // // // // // 			// dd[pt].real = ADC_Buffer[pt]+ ADC_Buffer[pt]<<2;
// // // // // // // // // // // // // // 			// dd[pt].real = 1000;
// // // // // // // // // // // // // // 			dd[pt].real = ADC_Buffer[pt];
// // // // // // // // // // // // // // 			dd[pt].imag = 0; //清零虚部
// // // // // // // // // // // // // // 		}
// // // // // // // // // // // // // // 		fft(dd, 64); //对当前数据进行傅立叶变换

// // // // // // // // // // // // // // 		for (pt = 0; pt < 65; pt++)
// // // // // // // // // // // // // // 		{
// // // // // // // // // // // // // // 			// printf("%f\n",dd[pt].real);
// // // // // // // // // // // // // // 			dd[pt].real = sqrt(dd[pt].real * dd[pt].real + dd[pt].imag * dd[pt].imag); //取均方根


// // // // // // // // // // // // // // 		}
// // // // // // // // // // // // // // 		FFT_Flash=1;	//
// // // // // // // // // // // // // // 		printf("A%f\r\n",dd[0].real);
// // // // // // // // // // // // // // 		printf("B%f\r\n",dd[1].real);
// // // // // // // // // // // // // // 		printf("C%f\r\n",dd[2].real);
// // // // // // // // // // // // // // 		printf("D%f\r\n",dd[4].real);
// // // // // // // // // // // // // // 		// printf("E%f\r\n",dd[6].real);
// // // // // // // // // // // // // // 		// printf("F%f\r\n",dd[8].real);
// // // // // // // // // // // // // // 		// printf("G%f\r\n",dd[10].real);
// // // // // // // // // // // // // // 		// printf("H%f\r\n",dd[12].real);
// // // // // // // // // // // // // // 		// printf("I%f\r\n",dd[14].real);
// // // // // // // // // // // // // // 		// printf("J%f\r\n",dd[16].real);
// // // // // // // // // // // // // // 		// printf("K%f\r\n",dd[18].real);
// // // // // // // // // // // // // // 		// printf("L%f\r\n",dd[20].real);
// // // // // // // // // // // // // // 		// printf("M%f\r\n",dd[22].real);
// // // // // // // // // // // // // // 		// printf("N%f\r\n",dd[24].real);
// // // // // // // // // // // // // // 		// printf("O%f\r\n",dd[26].real);
// // // // // // // // // // // // // // 		// printf("P%f\r\n",dd[28].real);
// // // // // // // // // // // // // // 		// printf("Q%f\r\n",dd[30].real);
// // // // // // // // // // // // // // 		// printf("B%f\n",dd[pt].real);
// // // // // // // // // // // // // // 		// printf("\n\n\n");
// // // // // // // // // // // // // // 		// printf("\n\n%f\n\n",dd[6].real);

// // // // // // // // // // // // // // 		DMA_Start(DMA_VECTOR_ADC, CTRL_DATA_ADC, DMA_MODE_NORMAL,
// // // // // // // // // // // // // // 				  DMA_SIZE_HALF, ADC_CNT, (uint16_t *)&ADC->ADCR, ADC_Buffer);
// // // // // // // // // // // // // // 	}
// // // // // // // // // // // // // // }
